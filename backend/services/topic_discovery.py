from utils.anthropic_client import AnthropicClient
import json
from typing import List, Dict, Optional
import re
from sqlalchemy.ext.asyncio import AsyncSession
from models.topic_recommendation import TopicRecommendation
from config import settings


class TopicDiscoveryService:
    """AI-powered topic discovery service"""

    def __init__(self, db: Optional[AsyncSession] = None):
        self.client = AnthropicClient()
        self.db = db

    async def discover(
        self,
        field: str,
        keywords: List[str],
        topic: str = None,
        description: str = None,
        num_suggestions: int = 5,
        use_deep_research: bool = False
    ) -> Dict:
        """
        使用 AI 推荐研究选题

        Args:
            field: 研究领域
            keywords: 关键词列表
            topic: 具体研究主题/细分方向 (可选)
            description: 研究方向描述 (可选)
            num_suggestions: 推荐数量，默认 5
            use_deep_research: 是否使用 Gemini Deep Research 进行深度调研

        Returns:
            包含 suggestions 列表的字典
        """

        # 构建基础上下文
        context_base = f"研究领域: {field}\n"
        if topic:
            context_base += f"具体主题/细分方向: {topic}\n"
        context_base += f"关键词: {', '.join(keywords)}"

        if description:
            context_base += f"\n研究方向描述: {description}"

        # ------------------------------------------------------------------
        # 分支 1: 使用 Gemini Deep Research 进行深度调研 (慢且深入)
        # ------------------------------------------------------------------
        if use_deep_research:
            try:
                from utils.gemini_client import GeminiDeepResearchClient
                # 使用配置文件中统一管理的 Google API Key
                deep_client = GeminiDeepResearchClient(api_key=settings.GOOGLE_API_KEY)
                
                # 1. 启动深度调研任务
                research_task = (
                    f"针对以下研究方向进行深度调研：\n{context_base}\n\n"
                    f"请广泛搜索最新的学术文献、技术博客和行业报告。"
                    f"目标是识别出 {num_suggestions} 个最具创新性和可行性的具体研究选题。"
                    f"请详细分析每个选题的背景、创新点和潜在影响。"
                )
                
                print(f"[TopicDiscovery] Starting Deep Research for: {field}...")
                research_report = await deep_client.run_research_task(research_task)
                
                # 2. 将调研报告转换为标准 JSON 格式
                # 使用 Gemini 模型进行直连格式化，绕过本地代理
                formatting_task = (
                    f"你是一个格式化助手，负责将调研报告转换为结构化数据。\n\n"
                    f"以下是一份关于 '{field}' 的深度调研报告：\n\n"
                    f"{research_report[:30000]}...\n\n" 
                    f"请根据这份报告，向我提取并整理出 {num_suggestions} 个最佳研究选题。"
                    f"请严格按照以下 JSON 格式输出列表（不要使用 Markdown 代码块）：\n"
                    f"[\n"
                    f"  {{\n"
                    f"    \"title\": \"选题标题\",\n"
                    f"    \"description\": \"详细描述\",\n"
                    f"    \"field\": \"所属领域\",\n"
                    f"    \"keywords\": [\"关键词1\", \"关键词2\"],\n"
                    f"    \"novelty_score\": 90,\n"
                    f"    \"feasibility_score\": 85,\n"
                    f"    \"reasoning\": \"推荐理由\"\n"
                    f"  }}\n"
                    f"]"
                )
                
                print(f"[TopicDiscovery] Formatting report using direct Gemini call...")
                response_text = await deep_client.generate_simple_content(formatting_task)
                
                # 标记签名
                signature = "-- Generated by Gemini Deep Research (Direct) --"
                
            except Exception as e:
                print(f"[TopicDiscovery] Deep Research failed: {e}. Falling back to standard generation.")
                # Fallback to standard flow
                return await self.discover(field, keywords, topic, description, num_suggestions, use_deep_research=False)

        # ------------------------------------------------------------------
        # 分支 2: 使用标准 LLM 直接生成 (快)
        # ------------------------------------------------------------------
        else:
            # 构建标准任务
            task = f"请针对上述研究领域"
            if topic:
                task += f"中的 '{topic}' 这一具体主题"
            task += f"，推荐 {num_suggestions} 个创新且可行的研究选题，严格按照 JSON 格式输出。"

            # 调用 AI
            response_text = await self.client.create_message(
                role="topic_discovery_expert",
                context=context_base,
                task=task
            )
            signature = None # Will extract from response or default

        # ------------------------------------------------------------------
        # 通用后期处理 (解析 JSON + 保存)
        # ------------------------------------------------------------------
        
        # 1. 尝试清理可能存在的 Markdown 标记 (Code block)
        cleaned_response = response_text.strip()
        if "```" in cleaned_response:
            # 提取 ```json ... ``` 或 ``` ... ``` 中的内容
            match = re.search(r"```(?:json)?(.*?)```", cleaned_response, re.DOTALL)
            if match:
                cleaned_response = match.group(1).strip()

        # 2. 移除可能存在的签名行 (如果模型输出了签名)
        lines = cleaned_response.split('\n')
        if lines and lines[-1].strip().startswith("-- Generated by"):
            cleaned_response = '\n'.join(lines[:-1]).strip()
            
        # 如果是普通模式且没有预设签名，尝试提取签名或设置默认值
        if not signature:
             signature = f"-- Generated by {self.client.model} (Fallback) --"

        # 3. 健壮的 JSON 解析
        try:
            data = json.loads(cleaned_response)
        except json.JSONDecodeError:
            # Fallback: 尝试在文本中寻找最大的 JSON 结构 ([...] 或 {...})
            try:
                match = re.search(r"(\[.*\]|\{.*\})", cleaned_response, re.DOTALL)
                if match:
                    json_str = match.group(1)
                    data = json.loads(json_str)
                else:
                    raise ValueError("No JSON structure found")
            except Exception:
                print(f"[TopicDiscovery] JSON Parse Error. Response preview: {cleaned_response[:200]}")
                raise ValueError(f"AI 返回数据格式异常，无法解析为有效 JSON。")

        # 4. 结构标准化 (统一转为 {"suggestions": [...]})
        suggestions = []
        if isinstance(data, list):
            suggestions = data
        elif isinstance(data, dict):
            if "suggestions" in data:
                suggestions = data["suggestions"]
            elif "topics" in data:
                suggestions = data["topics"]
            else:
                # 可能是单个对象
                if "title" in data and "field" in data:
                    suggestions = [data]
                else:
                    print(f"[TopicDiscovery] Warning: Dict returned but no 'suggestions' list found. Keys: {data.keys()}")
                    suggestions = [] 
        
        # 5. 字段校验与补全 (防止前端崩溃)
        final_suggestions = []
        for item in suggestions:
            if not isinstance(item, dict):
                continue
            
            # 使用 .get() 提供默认值，确保字段完整
            # 兼容性处理：尝试映射常见的其他键名 (如中文键名)
            title = item.get("title") or item.get("标题") or item.get("topic") or "未命名选题"
            desc = item.get("description") or item.get("描述") or item.get("desc") or "暂无描述"
            fld = item.get("field") or item.get("领域") or field
            novelty = item.get("novelty_score") or item.get("innovation_score") or item.get("创新性") or 0
            feasibility = item.get("feasibility_score") or item.get("可行性") or 0
            reasoning = item.get("reasoning") or item.get("analysis") or item.get("推荐理由") or ""
            kw = item.get("keywords") or item.get("关键词") or []
            
            clean_item = {
                "title": title,
                "description": desc,
                "field": fld,
                "keywords": kw if isinstance(kw, list) else [],
                "novelty_score": novelty,
                "feasibility_score": feasibility,
                "reasoning": reasoning
            }
            final_suggestions.append(clean_item)

        result = {"suggestions": final_suggestions}

        # Add signature to result
        result['model_signature'] = signature

        # 保存推荐历史到数据库
        if self.db:
            try:
                recommendation = TopicRecommendation(
                    research_field=field,
                    specific_topic=topic,
                    keywords=json.dumps(keywords, ensure_ascii=False),
                    description=description,
                    suggestions=json.dumps(result.get('suggestions', []), ensure_ascii=False),
                    model_signature=signature
                )
                self.db.add(recommendation)
                await self.db.commit()
                await self.db.refresh(recommendation)

                # 添加历史记录 ID 到返回结果
                result['recommendation_id'] = recommendation.id
            except Exception as e:
                print(f"Warning: Failed to save recommendation history: {e}")
                await self.db.rollback()

        return result
