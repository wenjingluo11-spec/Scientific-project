from utils.anthropic_client import AnthropicClient
import json
from typing import List, Dict, Optional
import re
from sqlalchemy.ext.asyncio import AsyncSession
from models.topic_recommendation import TopicRecommendation


class TopicDiscoveryService:
    """AI-powered topic discovery service"""

    def __init__(self, db: Optional[AsyncSession] = None):
        self.client = AnthropicClient()
        self.db = db

    async def discover(
        self,
        field: str,
        keywords: List[str],
        topic: str = None,
        description: str = None,
        num_suggestions: int = 5,
        use_deep_research: bool = False
    ) -> Dict:
        """
        使用 AI 推荐研究选题

        Args:
            field: 研究领域
            keywords: 关键词列表
            topic: 具体研究主题/细分方向 (可选)
            description: 研究方向描述 (可选)
            num_suggestions: 推荐数量，默认 5
            use_deep_research: 是否使用 Gemini Deep Research 进行深度调研

        Returns:
            包含 suggestions 列表的字典
        """

        # 构建基础上下文
        context_base = f"研究领域: {field}\n"
        if topic:
            context_base += f"具体主题/细分方向: {topic}\n"
        context_base += f"关键词: {', '.join(keywords)}"

        if description:
            context_base += f"\n研究方向描述: {description}"

        # ------------------------------------------------------------------
        # 分支 1: 使用 Gemini Deep Research 进行深度调研 (慢且深入)
        # ------------------------------------------------------------------
        if use_deep_research:
            try:
                from utils.gemini_client import GeminiDeepResearchClient
                deep_client = GeminiDeepResearchClient()
                
                # 1. 启动深度调研任务
                research_task = (
                    f"针对以下研究方向进行深度调研：\n{context_base}\n\n"
                    f"请广泛搜索最新的学术文献、技术博客和行业报告。"
                    f"目标是识别出 {num_suggestions} 个最具创新性和可行性的具体研究选题。"
                    f"请详细分析每个选题的背景、创新点和潜在影响。"
                )
                
                print(f"[TopicDiscovery] Starting Deep Research for: {field}...")
                research_report = await deep_client.run_research_task(research_task)
                
                # 2. 将调研报告转换为标准 JSON 格式
                # 使用普通模型 (AnthropicClient/Proxy) 进行格式化
                formatting_task = (
                    f"以下是一份关于 '{field}' 的深度调研报告：\n\n"
                    f"{research_report[:50000]}...\n\n" # 防止超出上下文限制
                    f"请根据这份报告，提取并整理出 {num_suggestions} 个最佳研究选题。"
                    f"严格按照 JSON 格式输出，字段要求与之前一致。"
                )
                
                response_text = await self.client.create_message(
                    role="topic_discovery_expert",
                    context="你是一个格式化助手，负责将调研报告转换为结构化数据。",
                    task=formatting_task
                )
                
                # 标记签名
                signature = f"-- Generated by Gemini Deep Research & {self.client.model} --"
                
            except Exception as e:
                print(f"[TopicDiscovery] Deep Research failed: {e}. Falling back to standard generation.")
                # Fallback to standard flow
                return await self.discover(field, keywords, topic, description, num_suggestions, use_deep_research=False)

        # ------------------------------------------------------------------
        # 分支 2: 使用标准 LLM 直接生成 (快)
        # ------------------------------------------------------------------
        else:
            # 构建标准任务
            task = f"请针对上述研究领域"
            if topic:
                task += f"中的 '{topic}' 这一具体主题"
            task += f"，推荐 {num_suggestions} 个创新且可行的研究选题，严格按照 JSON 格式输出。"

            # 调用 AI
            response_text = await self.client.create_message(
                role="topic_discovery_expert",
                context=context_base,
                task=task
            )
            signature = None # Will extract from response or default

        # ------------------------------------------------------------------
        # 通用后期处理 (解析 JSON + 保存)
        # ------------------------------------------------------------------
        
        # 1. Extract Signature if not already set
        cleaned_response = response_text
        lines = response_text.strip().split('\n')
        
        # Only extract if we haven't manually set a signature (standard flow)
        if not signature:
            if lines:
                last_line = lines[-1].strip()
                if last_line.startswith("-- Generated by") and last_line.endswith("--"):
                    signature = last_line
                    cleaned_response = '\n'.join(lines[:-1]).strip()
            
            if not signature:
                signature = f"-- Generated by {self.client.model} (Fallback) --"
        else:
            # Clean potential signature from the formatter model
            if lines and lines[-1].strip().startswith("-- Generated by"):
                 cleaned_response = '\n'.join(lines[:-1]).strip()


        # 解析 JSON
        try:
            # 尝试直接解析
            result = json.loads(cleaned_response)
        except json.JSONDecodeError:
            # 尝试提取 JSON 部分
            json_match = re.search(r'\{.*\}', cleaned_response, re.DOTALL)
            if json_match:
                try:
                    result = json.loads(json_match.group())
                except json.JSONDecodeError:
                    raise ValueError(f"AI 返回格式错误，无法解析为有效 JSON。原始响应: {cleaned_response[:200]}...")
            else:
                raise ValueError(f"AI 返回格式错误，无法解析为有效 JSON。原始响应: {cleaned_response[:200]}...")

        # Add signature to result
        result['model_signature'] = signature

        # 保存推荐历史到数据库
        if self.db:
            try:
                recommendation = TopicRecommendation(
                    research_field=field,
                    specific_topic=topic,
                    keywords=json.dumps(keywords, ensure_ascii=False),
                    description=description,
                    suggestions=json.dumps(result.get('suggestions', []), ensure_ascii=False),
                    model_signature=signature
                )
                self.db.add(recommendation)
                await self.db.commit()
                await self.db.refresh(recommendation)

                # 添加历史记录 ID 到返回结果
                result['recommendation_id'] = recommendation.id
            except Exception as e:
                print(f"Warning: Failed to save recommendation history: {e}")
                await self.db.rollback()

        return result
